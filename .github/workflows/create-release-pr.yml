name: Create Release PR

on:
  workflow_dispatch:
    inputs:
      release_type:
        description: 'Release type'
        required: true
        default: 'patch'
        type: choice
        options:
          - patch
          - minor
          - major
      include_features:
        description: 'Include feature descriptions in customer notes?'
        required: true
        default: true
        type: boolean
      dry_run:
        description: 'Dry run (create PR but do not merge)'
        required: true
        default: true
        type: boolean

env:
  GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
  ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}
  GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

jobs:
  create-release-pr:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Setup Ruby
        uses: ruby/setup-ruby@v1
        with:
          ruby-version: '3.3.3'
          bundler-cache: true

      - name: Install dependencies
        run: |
          gem install octokit

      # Python for release-notes generation
      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Install Python deps
        run: |
          pip install --upgrade pip
          pip install anthropic

      - name: Get current version
        id: get-version
        run: |
          CURRENT_VERSION=$(./Scripts/get-version.sh)
          echo "current_version=$CURRENT_VERSION" >> $GITHUB_OUTPUT
          echo "Current version: $CURRENT_VERSION"

      - name: Calculate new version
        id: new-version
        run: |
          CURRENT_VERSION="${{ steps.get-version.outputs.current_version }}"
          RELEASE_TYPE="${{ github.event.inputs.release_type }}"

          IFS='.' read -r major minor patch <<< "$CURRENT_VERSION"

          case "$RELEASE_TYPE" in
            "major")
              NEW_MAJOR=$((major + 1))
              NEW_MINOR=0
              NEW_PATCH=0
              ;;
            "minor")
              NEW_MAJOR=$major
              NEW_MINOR=$((minor + 1))
              NEW_PATCH=0
              ;;
            "patch")
              NEW_MAJOR=$major
              NEW_MINOR=$minor
              NEW_PATCH=$((patch + 1))
              ;;
          esac

          NEW_VERSION="$NEW_MAJOR.$NEW_MINOR.$NEW_PATCH"
          echo "new_version=$NEW_VERSION" >> $GITHUB_OUTPUT
          echo "New version: $NEW_VERSION"

      - name: Generate short release notes
        id: release-notes
        run: |
          python3 -c "
          import anthropic
          import os
          import subprocess

          # Setup Anthropic Claude
          client = anthropic.Anthropic(api_key=os.environ['ANTHROPIC_API_KEY'])

          # Get commits since last tag
          last_tag_result = subprocess.run(['git', 'describe', '--tags', '--abbrev=0'], capture_output=True, text=True)
          if last_tag_result.returncode != 0:
              print(f"‚ùå Failed to get last tag: {last_tag_result.stderr}")
              exit(1)

          last_tag = last_tag_result.stdout.strip()
          if not last_tag:
              print("‚ùå No previous tags found")
              exit(1)

          print(f"üìù Getting commits since last tag: {last_tag}")

          result = subprocess.run(['git', 'log', '--oneline', '--no-merges', f'{last_tag}..HEAD'], capture_output=True, text=True)
          if result.returncode != 0:
              print(f"‚ùå Failed to get commits: {result.stderr}")
              exit(1)

          commits = result.stdout.strip().split('\n')

          # Filter and categorize commits
          features = []
          bugfixes = []

          for commit in commits:
              if commit:
                  msg = commit.split(' ', 1)[1] if ' ' in commit else commit
                  if msg.startswith('feat:') or msg.startswith('‚ú®'):
                      features.append(msg)
                  elif msg.startswith('fix:') or msg.startswith('üêõ'):
                      bugfixes.append(msg)

          # Respect include_features input
          if os.environ.get('INCLUDE_FEATURES', 'true').lower() != 'true':
              features = []

          # Generate short, customer-friendly release notes
          prompt = f'''Generate SHORT, customer-friendly release notes for iOS app version {os.environ['NEW_VERSION']}.

          Key changes:
          Features: {features[:3]}  # Top 3 features only
          Bugfixes: {bugfixes[:2]}  # Top 2 bugfixes only

          Requirements:
          - MAXIMUM 5 bullet points total
          - Use warm, friendly language
          - Focus on user benefits
          - Keep each point under 15 words
          - No technical jargon

          Format as simple bullet points, no headers or markdown.'''

          response = client.messages.create(
              model='claude-4',
              max_tokens=200,
              temperature=0.8,
              messages=[{'role': 'user', 'content': prompt}]
          )

          release_notes = response.content[0].text.strip()

          # Save to file
          with open('release-notes.txt', 'w') as f:
              f.write(release_notes)

          # Log feature inclusion status
          if features:
              print(f'‚úÖ Features included: {len(features)} features found')
          else:
              print('üîç Features excluded: No features in release notes')

          print('Short release notes generated successfully!')
          "
        env:
          NEW_VERSION: ${{ steps.new-version.outputs.new_version }}
          INCLUDE_FEATURES: ${{ github.event.inputs.include_features }}

      - name: Update version in Xcode project
        run: |
          # Ensure dev branch
          git fetch --no-tags --prune origin dev
          git checkout -B dev origin/dev

          # Update version in Xcode project (GNU sed)
          sed -i 's/MARKETING_VERSION = [0-9]*\.[0-9]*\.[0-9]*;/MARKETING_VERSION = ${{ steps.new-version.outputs.new_version }};/g' Convos.xcodeproj/project.pbxproj

          # Commit version update
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"
          git add Convos.xcodeproj/project.pbxproj
          git commit -m "chore: bump version to ${{ steps.new-version.outputs.new_version }}" || echo "No changes to commit"

          # Respect dry_run for push
          if [ "${{ github.event.inputs.dry_run }}" != "true" ]; then
            git push origin dev
          else
            echo "Dry run: skipping push"
          fi

      - name: Create Pull Request
        if: ${{ github.event.inputs.dry_run != 'true' }}
        id: create-pr
        run: |
          python3 -c "
          import os
          import subprocess

          # Read release notes
          with open('release-notes.txt', 'r') as f:
              release_notes = f.read()

          # Create PR description
          pr_body = f'''# üöÄ Release v{os.environ['NEW_VERSION']}

          {release_notes}

          ---
          *Generated automatically by GitHub Actions*'''

          # Create PR using GitHub CLI
          pr_result = subprocess.run([
              'gh', 'pr', 'create',
              '--title', f'Release v{os.environ[\"NEW_VERSION\"]}',
              '--body', pr_body,
              '--base', 'main',
              '--head', 'dev',
              '--label', 'release',
              '--label', 'production'
          ], capture_output=True, text=True)

          if pr_result.returncode == 0:
              print('‚úÖ Pull Request created successfully!')
              print(pr_result.stdout)
          else:
              print('‚ùå Failed to create PR:')
              print(pr_result.stderr)
              exit(1)
          "
        env:
          NEW_VERSION: ${{ steps.new-version.outputs.new_version }}
          CURRENT_VERSION: ${{ steps.get-version.outputs.current_version }}
          INCLUDE_FEATURES: ${{ github.event.inputs.include_features }}

      - name: Show PR Preview (Dry Run)
        if: ${{ github.event.inputs.dry_run == 'true' }}
        run: |
          echo "üîç DRY RUN MODE: PR Creation Preview"
          echo "====================================="
          echo "Title: Release v${{ steps.new-version.outputs.new_version }}"
          echo ""
          echo "Body preview:"
          echo "-------------"
          cat release-notes.txt
          echo ""
          echo "In a real run, this would create a PR from dev to main"
          echo "with the above content."

      - name: Output summary
        run: |
          echo "üéâ Release PR workflow completed!"
          echo "New version: ${{ steps.new-version.outputs.new_version }}"
          echo "Version updated in dev branch"

          if [ "${{ github.event.inputs.dry_run }}" = "true" ]; then
            echo "üîç DRY RUN MODE: No changes pushed to dev branch"
            echo "Pull Request: Preview shown (dry run mode)"
            echo "Features included: ${{ github.event.inputs.include_features }}"
          else
            echo "‚úÖ Changes pushed to dev branch"
            echo "Pull Request: Created from dev to main"
            echo "Features included: ${{ github.event.inputs.include_features }}"
          fi

          echo ""
          echo "üìù Next steps:"
          echo "1. Review the generated PR"
          echo "2. Use 'Rebase and merge' button (linear history)"
          echo "3. Bitrise will build and deploy automatically"
