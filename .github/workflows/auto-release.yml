name: Auto Release

on:
  push:
    tags:
      - '*.*.**' # Triggers on semantic version tags (e.g., 1.0.0, 1.0.0-dev.123456, no v prefix)

env:
  GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
  GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

jobs:
  auto-release:
    runs-on: ubuntu-latest
    permissions:
      contents: write       # Read/write repository contents, tags, and releases
      actions: read         # Read workflow status
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Install dependencies
        run: |
          pip install anthropic

      - name: Extract version from tag
        id: version
        run: |
          VERSION=${GITHUB_REF#refs/tags/}
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "Version: $VERSION"

      - name: Generate short release notes
        id: release-notes
        run: |
          python3 -c '
          import anthropic
          import os
          import subprocess

          # Setup Anthropic Claude
          client = anthropic.Anthropic(api_key=os.environ["ANTHROPIC_API_KEY"])

          # Get current tag from the trigger event
          current_tag = os.environ["GITHUB_REF"].replace("refs/tags/", "")

          # Get the previous tag (the one before current)
          tags_result = subprocess.run(["git", "tag", "--sort=-version:refname"], capture_output=True, text=True)
          if tags_result.returncode != 0:
              print(f"Failed to get tags: {tags_result.stderr}")
              exit(1)

          tags = tags_result.stdout.strip().split("\n")
          previous_tag = None

          # Find the tag before the current one
          for i, tag in enumerate(tags):
              if tag == current_tag and i + 1 < len(tags):
                  previous_tag = tags[i + 1]
                  break

          if previous_tag:
              print(f"Getting commits between {previous_tag} and {current_tag}")
              result = subprocess.run(["git", "log", "--oneline", "--no-merges", f"{previous_tag}..{current_tag}"], capture_output=True, text=True)
          else:
              print(f"First release - getting all commits up to {current_tag}")
              result = subprocess.run(["git", "log", "--oneline", "--no-merges", current_tag], capture_output=True, text=True)
          if result.returncode != 0:
              print(f"Failed to get commits: {result.stderr}")
              exit(1)

          commits = result.stdout.strip().split("\n")

          # Handle empty commit list
          if not commits or (len(commits) == 1 and not commits[0]):
              print("No commits found in range, using generic message")
              commits = ["General improvements and updates"]

          # Filter and categorize commits
          features = []
          bugfixes = []
          other_changes = []

          for commit in commits:
              if commit:
                  msg = commit.split(" ", 1)[1] if " " in commit else commit
                  if msg.startswith("feat"):
                      features.append(msg)
                  elif msg.startswith("fix"):
                      bugfixes.append(msg)
                  else:
                      other_changes.append(msg)

          # Generate short, customer-friendly release notes
          version = os.environ["VERSION"]
          prompt = f"Generate SHORT, customer-friendly release notes for iOS app version {version}. Key changes: Features: {features[:3] if features else []}, Bugfixes: {bugfixes[:2] if bugfixes else []}, Other: {other_changes[:2] if other_changes and not features and not bugfixes else []}. Requirements: MAXIMUM 5 bullet points total, use warm friendly language, focus on user benefits, keep each point under 15 words, no technical jargon. Format as simple bullet points, no headers or markdown."

          # Use model from environment variable with fallback
          model = os.getenv("CLAUDE_MODEL", "claude-sonnet-4-20250514")

          try:
              response = client.messages.create(
                  model=model,
                  max_tokens=200,
                  temperature=0.8,
                  messages=[{"role": "user", "content": prompt}]
              )

              release_notes = response.content[0].text.strip()

          except Exception as e:
              print(f"Claude API failed: {e}")
              print("Using fallback release notes...")

              # Fallback release notes if API fails
              release_notes = f"Version {version}\n- Bug fixes and performance improvements\n- Enhanced user experience\n- Updated for latest iOS compatibility"

          # Save to file
          with open("release-notes.txt", "w") as f:
              f.write(release_notes)

          print("Release notes saved successfully!")
          '
        env:
          VERSION: ${{ steps.version.outputs.version }}
          ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}

      - name: Store release notes for later use
        run: |
          echo "Release notes generated and stored in release-notes.txt"
          echo "These will be used in the PR description and GitHub Release"

      - name: Create GitHub Release
        run: |
          VERSION="${{ steps.version.outputs.version }}"
          RELEASE_NOTES=$(cat release-notes.txt)

          # Check if release already exists
          if gh release view "$VERSION" > /dev/null 2>&1; then
            echo "Release $VERSION already exists, updating it..."
            gh release edit "$VERSION" \
              --title "Release $VERSION" \
              --notes "$RELEASE_NOTES"
          else
            echo "Creating GitHub Release $VERSION..."
            gh release create "$VERSION" \
              --title "Release $VERSION" \
              --notes "$RELEASE_NOTES" \
              --target "$GITHUB_SHA"
          fi

          echo "GitHub Release created/updated with release notes"
          echo "   Bitrise will read from: https://github.com/${{ github.repository }}/releases/tag/$VERSION"

      - name: Verify version in dev branch
        run: |
          # Verify that the version in dev branch matches the tag
          git fetch --no-tags --prune origin dev
          current_version=$(git show origin/dev:Convos.xcodeproj/project.pbxproj | \
            grep -o 'MARKETING_VERSION = [0-9]*\.[0-9]*\.[0-9]*;' | head -1 | \
            sed 's/MARKETING_VERSION = \([0-9]*\.[0-9]*\.[0-9]*\);/\1/')
          tag_version="${{ steps.version.outputs.version }}"
          # Strip any prerelease/build suffix from tag version for comparison
          tag_version_base="${tag_version%%-*}"

          if [ "$current_version" != "$tag_version_base" ]; then
            echo "Version mismatch: dev branch has $current_version, but tag base version is $tag_version_base (full tag: $tag_version)"
            echo "This suggests the version wasn't properly updated in dev branch before tagging"
            exit 1
          fi

          echo "Version verified: dev branch has $current_version, tag base version is $tag_version_base (full tag: $tag_version)"


      - name: Output summary
        run: |
          echo "Auto-release workflow completed!"
          echo "Version: ${{ steps.version.outputs.version }}"
          echo "GitHub Release: Created/updated with release notes"
          echo ""
          echo "Release pipeline created:"
          echo "  - GitHub Release available for Bitrise"
          echo "  - Release notes will be used by Bitrise for App Store submission"
          echo ""
          echo "Next steps:"
          echo "1. Use 'make promote-release' to fast-forward merge dev to main"
          echo "2. Bitrise will build and deploy automatically"
